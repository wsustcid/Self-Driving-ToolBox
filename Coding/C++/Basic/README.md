<!--
 * @Author: Shuai Wang
 * @Github: https://github.com/wsustcid
 * @Version: 0.0.0
 * @Date: 2022-04-18 10:24:26
 * @LastEditTime: 2022-04-19 17:47:59
-->
- [1. C++编程基础](#1-c编程基础)
  - [1.1 对象](#11-对象)
  - [1.2 表达式](#12-表达式)
  - [1.3 语句](#13-语句)
  - [1.4 函数](#14-函数)
  - [1.5 类](#15-类)
  - [1.6 指针](#16-指针)
  - [1.7 文件读写](#17-文件读写)

## 1. C++编程基础
### 1.1 对象
**对象的定义和初始化**  
对象是程序中可以操作的基本单位，为了定义对象，必须为它命名，并明确其数据类型，有时还可以对其初始化赋予其初始值：
  - 对象的名称：可以是任意字母（区分大小写）、数字、下划线的组合，但不能以数字开头，也不能与程序语言本身已经定义的关键字完全一致。
  - 对象的类型：对象都要属于某个特定的数据类型，其决定了对象所能持有的数值范围以及其应该占用的内存空间大小；其类型可以是基本的内置数据类型，也可以是自定义的类型。
  - 对象初始化：有两种语法，一种是常规的使用赋值语句`=`进行初始化，另一种是使用构造函数语法，如`int num(0)`。二者的区别在于赋值语句仅能对对象进行进行单一值的初始化，如果对象需要多个初值，比如复数对象，就需要使用构造函数初始化语法：`complex<double> purei(0,7)`

**基本内置数据类型**  
基本的内置数据类型包括整数(int), 浮点数(float), 字符(char), 以及布尔值(bool)
  - int 包括`signed int` 和 `unsigned int`，表示范围为4个字节，还有`short`2个字节以及`long`8个字节
  - 浮点数`float`为单精度，还有`double` 双精度以及`long double`长双精度
  - 字符常量由一组单引号括住，通常分为两类：一类是可打印字符，如字母、数字、标点符号等；另一类是不可打印字符，如换行符`\n`,制表符`\t`等
  - 布尔对象的值为`true` 或 `false`

**可变对象与常量对象**  
对象除了有类型这一必要属性之外，还有可变对象和常量对象之分
  - 通常对象的值一般都会在程序运行过程中改变，这种就是普通的直接用数据类型定义的可变对象
  - 如果某个对象比如圆周率等，其值永远不会改变，或需要防止其被无意中改动，就用`const`关键字定义为常量对象，如`const int MAXNUM = 100`。const 对象在定义时必须进行初始化，且一旦获得初值以后，就无法再有任何变动，任何企图为其指定新值的操作都会产生编译错误。


### 1.2 表达式
基于运算符实现对象间的运算，便构成了基本的表达式。

**基本运算符**  
内置数据类型都可以运用以下几种基本运算符：
  - 算数运算符：包括`+, -, *, /, %`; 注意：两个整数相除会产生另一个整数，小数部分直接舍弃
  - 关系运算符：结果不是true,就是false,包括`==, !=, >, <, >=, <=`
  - 逻辑运算符：包括`&&, ||, !`
  - 复合赋值运算符：用于在对象身上使用某个运算符，并重新赋值给该对象，包括`+=, -=, *=, /=, %=`

**其他常用运算符**
  - 条件运算符： `expr ? 如果expr为true，执行这里 : 否则，执行这里`, 构成了条件表达式
  - 递增递减运算符：`cnt++, cnt--`; 注意，递增递减都有前置和后置两种形式，前置是先递增后再来拿使用，后置相反

**运算符的优先级**  
当使用内置的运算符时，如果同一个表达式中包含多个运算符，其求值顺序是由每个运算符事先定义的优先级决定的，可使用小括号来改变内置运算符的优先级。各种运算符的优先级从高到低罗列如下（同一行优先级相同，按顺序由左至右运算）：
  - 逻辑运算符 `!`, 此运算符优先级最高，与其他一起使用时要特别注意，比如判断偶数`! val%2`就不同
  - 算数运算符 `*, /, %`
  - 算数运算符 `+, -`
  - 关系运算符 `<, >, <=, >=`
  - 关系运算符 `==, !=`
  - 逻辑运算符 `&&`
  - 逻辑运算符 `||`
  - 赋值运算符 `=`


### 1.3 语句
目前，我们已经学会了如何使用数据类型定义对象，并结合运算符撰写表达式进行算数运算或关系、逻辑运算。但仅仅依靠这些还无法编写真正的程序，进一步结合条件语句和循环语句，便构成了任何复杂代码的基石：
  - if 语句让我们依据某个表达式的结果(true or false)来决定是否执行其后一条或多条语句，else 子句可以用于连续检验多个测试条件
  - 循环语句让我们根据某个表达式的结果(true or false)重复执行单一的或连续的多条语句

**if 条件语句**
  - if 语句中的条件表达式必须写在括号内，如果该表达式为真，其后紧接着的一条语句便会被执行，如果想要连续执行多条语句，则需要用花括号将其括住形成语句块
  - else 子句除了作为if条件不满足的情况，还可以和if结合，继续对判断情况进行细分 `else if (expr)`

**switch条件语句**  
当if-else 子句比较多时，较难进行精准划分，如果判断条件的值属于整数类型，可以改用switch语句来代替一大堆的`if-else-if`子句：
  - 关键字switch之后紧接一个由小括号括住的表达式，该表达式的值必须是整数，然后跟一组case标签，每个标签之后都指定一个常量表达式。当switch后表达式的值被计算出之后，便依次和每个case标签的值进行比较，如果找到相符的case标签，则执行该语句，找不到便执行default标签，如果default未定义，则不执行任何操作
  - 注意，每个case标签内部最后都会加一个break语句，如果不加，则不会跳出switch语句，执行完此case后，还会继续执行后面的case

**循环语句**
只要条件表达式不断成立（运算结果为true），循环语句便会不断的执行单一语句或整个语句块，我们通过在循环体内部对表达式元素值进行更新从而确定是否继续迭代。典型的循环语句包括while循环和for循环：
  - while循环与条件语句类似，都是`关键字(expr)`, 后跟花括号括住的语句块
  - for循环的基本形式为`for (init-statement; condition; expression) {statement}` 分别指定初始迭代条件、迭代判断条件和每次迭代后的迭代控制表达式
  - 可以利用`break`语句来跳出当前循环(最近的循环)，或使用`continue`语句跳过后续的语句，从下一次循环继续


### 1.4 函数
函数的主要功能就是根据输入，计算想要的输出，解决特定的具体问题。函数的实现过程包括根据具体问题的需要定义需要处理的对象，通过相关表达式，结合条件和循环语句，撰写具有特定功能的函数。c++ 函数的定义包含四个部分：
  - 返回值类型: 一般用于返回运算的结果，没有返回值时可以定义为 `void`;
  - 函数名称: 这个由自己定义
  - 参数列表: 用括号括住，里面包含函数需要输入的参数，格式为`(参数类型 参数名, 参数类型 参数名)`
  - 函数体: 用大括号标出，在其内部编写相关代码，如对输入数据进行处理以及返回操作结果

注意，每个c++程序都是从一个名为`main`的函数开始执行，必须定义且只能有一个。


### 1.5 类
而C++的强大之处并不在于以上任意一种编程语言都具有的基本特性，主要在于其对数据对象的抽象能力，即class的定义与使用。

所谓类，就是用户自定义的数据类型，class机制让我们可以将各种基础数据类型进行重新组织，并定义一些基础操作，作为新的数据类型加入到程序中，从而在程序内实现对类型层次化的抽象：
  - 比如一个照相机通常包含三维的空间位置、三维的视角方向以及一个窗口的宽-高比，总计七个浮点数
  - 如果我们单独定义七个浮点数，必然会让我们在“照相机的抽象性质”和“对应于其七个浮点数”之间来还切换
  - 如果我们先定义一个由三个浮点数组成的`Point3D`类，再用两个`Point3D`和一个浮点数组成一个`Camera`类，这样我们就可以直接对照相机进行操作，而不是单独操作对应的浮点数

**class定义**  
一般分为两部分，分别写在不同的文件中：
  - 头文件：用来声明该类所提供的各种操作行为
  - 程序代码文件：包含这些操作行为的实现内容

要想使用某个类，必须先在程序中包含其头文件，这样程序就可以知道该class的定义
 - 比如最常用的标准“输入/输出库”，里面包含了相关的整套class，用来支持对终端和文件的输入与输出，我们通过`#include <iostream> ` 来声明对该类的使用
 - 基于该声明，可以直接利用已经定义好的`cout`对象，结合output运算符`<<`，将数据定向到`cout`, 如`cout<<"Hello World"`

在声明头文件之后，我们通常会加一个`using namespace std;` 用来指明在本代码文件内，我们默认使用标准库的命名空间，`std`就是c++标准库所驻之命名空间的名称。
  - 命名空间`namespace`是一种将库名称封装起来的方法
  - 如果我们代码文件内有两个不同的实体`entity`具有相同的名称，则无法区分二者，我们使用命名空间，就可以将二者进行区分。
  - 在程序中声明使用的命名空间，就可以将其包含的名称曝光，这样在使用时就可以直接使用，否则就得用`std::cout`


c++自定义的基础数据类型功能有限，除了自己根据需要定义相关类，C++及其标准库中还包含了其他数据类型，其中数组是最常用的数据类型之一，数组有array和vector两种实现方式，二者都是为了对同一类型的数据以序列的形式进行组织

**Array**  
  - 要定义array，必须分别指定元素类型、array名称及其尺寸大小：`int arr[10]`，定义时也可不指定大小`int arr[]={x,x}`，编译器会根据初值的数量进行推断
  - array对象初始化可直接使用中括号指定每个元素的值，元素个数不能超过array指定的尺寸，可以小于(未指定的默认为0)

**Vector**  
vector定义前必须包含vector头文件，因为vector是一个模板类，因此必须在类名后的尖括号内指定元素类型，大小则写在对象名后的小括号中：`vector<int> vec(10)`。vector的初始化有6种方式：
  - (1). 默认初始化：不指定，全部为0 `vector<int> vec;` 
  - (2). 拷贝初始化：直接拷贝另一个vector的元素`vector<int> vec(vec1);` 
  - (3). 列表初始化：`vector<int> vec={1,2};` 
  - (4). 指定范围初始化：`vector<int> vec(vec1.begin()+2, vec1.end()-1);` 
  - (5). 默认值初始化： `vector<int> vec(7);` 
  - (6). 指定值初始化 `vector<int> vec(7,3);`

无论是array还是vector，都可以通过索引(从0开始)指定容器中的某个位置，从而访问该位置上的元素

**string**  
字符串是存储在一段连续内存中的一系列字符，C++处理字符串的方式有两种，一种是C语言中的C风格字符串，另一种是基于string类库的方法。
  - C风格字符串的详细用法[详见](https://blog.csdn.net/digitalkee/article/details/111815552)


### 1.6 指针
除了通过名称+索引访问vector内的每个元素，还可以使用指针，通过操作指针(代表某个特定的地址)，而不再直接操作对象，为程序引入一层间接性。
  - 指针即是某个特定类型对象的地址，因此和定义对象一样，定义指针同样需要指定其指向元素的类型，为了和定义对象相区分，元素类型后还要加上星号,如`int *pr`，代表指向某个int型对象的指针
  - 指针代表地址，因此其初始化就是给他指定某个对象的地址，需要用到取地址符`&`，即 `pr = &ival`
  - 进一步的，如果要访问指针所指内存地址上的对象，依然使用星号 `int a = *pr`进行提领操作
  - 注意：因为指针可以不指向任何对象(其地址为0)，因此在对指针进行提领操作之前要确定其指向某个对象`if (pr)`

**dot成员选择运算符与arrow成员选择运算符**  
  - 通常类对象都会包含一系列可以调用的对象，可以使用对象名结合dot运算符进行调用`vec.empty()`
  - 但如果定义了该对象的指针，则可以通过指针，结合arrow运算符进行调用`vec->empty()`（数组名就是指针）
  - 指针还可以和下表运算符结合吗？当然可以！只要先进行提领就可以了`(*vec_ptr)[1]`,同样在提领前一定要先判断指针有效性！


**关于`char **argv` 与 `char* argv[]`**  
  - `char **argv` 可以看做`char* *argv`，首先`*argv`是定义指针的方式，代表argv是一个指针，`char*`代表指针指向的内容，说明其指向的内容也是一个指针，内容类型为char
  - `char* argv[]`比较好理解，就是一个数组argv，里面存的是指针，指针指向的内容类型为char。
  - 由数组名argv也是数组首地址可以看出，二者功能相同

### 1.7 文件读写
函数的输入输出除了通过终端进行输入输出以外，还可以通过文件进行长久的保存和读取。该功能的实现需要文件读写类 `#include<fstream>`。

**写文件**  
```c++
// 定义输出内容到指定文件的file stream对象，同时传入文件地址
ofstream outfile("data.txt"); // 若文件不存在，则会自动创建；默认会从头开始写
ofstream outfile("adta.txt", ios_base::app); // 可以设定追加模式 
// 文件有可能打开失败，因此在进行写入操作之前，必须确定文件的确已经打开成功: 直接检验类对象的真伪
if (outfile)
{
  outfile<< usr_name << ' ' ;
}
```

**读文件**  
```c++
ifstream infile("data.txt") 
if (infile)
{
  while(infile>>name)
  {
    // 一直读到文件末尾
  }
}
```

**读写文件**  
```c++
fstream iofile("data.txt", ios_base::in|ios_base::app); // 指定追加模式
if (iofile)
{
  iofile.seekg(0); //将文件重新定位至起始处，否则会在文件末尾
}
```

