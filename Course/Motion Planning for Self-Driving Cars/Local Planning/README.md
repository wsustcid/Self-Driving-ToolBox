<!--
 * @Author: Shuai Wang
 * @Github: https://github.com/wsustcid
 * @Version: 1.0.0
 * @Date: 2021-09-27 17:53:59
 * @LastEditTime: 2021-10-11 19:48:29
-->
- [7. 平滑局部规划](#7-平滑局部规划)
  - [7.1 参数曲线](#71-参数曲线)
    - [7.1.1 边界条件与运动学约束](#711-边界条件与运动学约束)
    - [7.1.2 参数曲线](#712-参数曲线)
    - [7.1.3 五次样条](#713-五次样条)
    - [7.1.4 多项式螺旋线](#714-多项式螺旋线)
  - [7.2 优化问题建模](#72-优化问题建模)
    - [7.2.1 约束条件](#721-约束条件)
    - [7.2.2 目标函数](#722-目标函数)
  - [7.3 Python 优化器](#73-python-优化器)
  - [7.4 Conformal Lattice](#74-conformal-lattice)
    - [7.4.1 路径生成](#741-路径生成)
    - [7.4.2 碰撞检查](#742-碰撞检查)
    - [7.4.3 路径选择](#743-路径选择)
  - [7.5 速度生成](#75-速度生成)
    - [7.5.1 终点速度](#751-终点速度)
    - [7.5.2 线性斜坡速度](#752-线性斜坡速度)
    - [7.5.3 梯形速度](#753-梯形速度)
  - [7.6 补充阅读材料](#76-补充阅读材料)


# 7. 平滑局部规划
局部规划器是分层规划器的一部分，用与以一种无碰撞、高效、并且舒适的方式执行行为规划器的决策行为。它的输出结果可以是一条轨迹，即空间中一系列的点并且包含每个点对应的时间，或是一条路径和对应的速度分布，即空间中一系列点以及对应的每个点所要求的速度。其规划结果可以用作后续控制器的参考输入。


## 7.1 参数曲线
### 7.1.1 边界条件与运动学约束
对于路径规划问题，其核心便是给定起始位置、朝向以及曲率，找到一条到达终点位置、朝向和曲率且满足动力学约束的路径。因此从优化的角度，起点和终点值可以看做问题的边界条件，车辆运动的运动学约束可以看做优化变量的连续时间约束。
  - 对于边界条件，不管求解优化问题得到的可行解路径多么的好，如果边界条件不满足，这条路径对我们也是没用的，因为我们边界不满足，就代表我们并没有实现我们的核心目标：到达我们期望的目标点。
  - 对于运动学约束，我们唯一要限制的就是沿着路径的最大曲率。但其实这也不容易满足，因为沿着一条连续的路径通常有无限个点。因此，我们通常沿着路径在不同位置对曲率进行采样，实际对这些采样点的曲率进行限制。

<div align=center><img src=./figs/constraints.png width=500></div>

### 7.1.2 参数曲线
为了简化对优化问题的表示，我们将路径定义为参数曲线。一条参数曲线通常由一组具有特定参数的方程描述，如
$$ \textbf{r}(u) = <x(u), y(u)> \\
   u \in [0, 1] \\
   x(u) = \alpha_0 + \alpha_1 u + \alpha_2 u^2 + \alpha_3 u^3 \\
   y(u) = \beta_0 + \beta_1 u + \beta_2 u^2 + \beta_3 u^3$$
  
  - $\textbf{r}$ 代表一条参数曲线，具体来讲，是三次样条的形式，对于一个给定u,便代表一个具体的位置点
  - 参数$u$ 代表对路径的遍历,范围从0到1变化，代表从路径的起点到终点变化，也可以是弧长
  - $x,y$代表路径的位置

对于无人驾驶问题，我们经常要求（但不总是）路径是一条参数的曲线，因为这样我们就可以通过构建目标函数 $f$ 来实现对路径的优化：
$$ min f(\textbf{r}(u)) \\
   s.t. \quad c(\textbf{r}(u)) \leq \alpha \quad \forall u \in [0,1] \\
    \textbf{r}(0) = \beta_0 \\
    \textbf{r}(u_f) = \beta_f $$
  - 边界条件由$\beta_0, \beta_f$描述
  - 运动学约束由$\alpha$描述
  - 注意目标函数其实是一个泛函，他的输入是一个函数，输出是一个实值，可以实现对整个参数空间的优化。

在上一节的反应式规划器中，我们采用一系列的点来表示路径，是一种非参数化的路径(Non-Parametric Path)。

在无人驾驶领域，有两种常用的路径参数化类型
  - 一种是五次样条，由车辆$x,y$位置的五阶多项式函数定义
  - 另一种是多项式螺旋线，由关于弧长的多项式曲线方程描述
  - 图示为五次样条和三阶多项式螺旋线，参数化曲线均满足我们之前讨论的边界条件

<div align=center><img src=./figs/spline_spiral.png width=600></div>

### 7.1.3 五次样条
五次样条由两个方程描述，分别用来描述沿着样条$x,y$坐标值的变化
$$ x(u) = \alpha_0 + \alpha_1 u + \alpha_2 u^2 + \alpha_3 u^3 + \alpha_4 u^4 + \alpha_5 u^5 \\
  y(u) = \beta_0 + \beta_1 u + \beta_2 u^2 + \beta_3 u^3 + \beta_4 u^4 + \beta_5 u^5 \\
  u \in [0,1] $$
  - 五次样条的一个很好的特性是，对于给定的位置、航向和曲率边界条件$x, y,\theta, \kappa$，满足它们的样条系数有一个直接封闭形式的解
  - 解的形式虽然很长但相比于用迭代优化的方式生成路径，计算起来更为方便，它允许我们立即生成边界条件的可行解，并且可以进一步优化，相关细节见参考文献

五次样条的缺点其很难将曲率约束在一定的边界集合内，由参数曲线的曲率方程可以看出，其曲率函数并不是多项式，因此在样条中可能隐含曲率的不连续性，这使得很难在样条的整个定义域上获得满足曲率约束的近似

$$ \kappa(u) = \frac{x'(u)y''(u) - x''(u)y'(u)}{(x'(u)^2 + y'(u)^2)^\frac{3}{2}} $$

### 7.1.4 多项式螺旋线
多项式螺旋线由曲率关于弧长的函数进行定义，其提供了曲率的闭式解。对于无人驾驶任务，通常选择三阶多项式，当然更高阶也是可以的。使用多项式螺旋的主要优点是它们的结构非常有利于满足路径规划问题通常需要的近似曲率约束。
$$ \kappa(s) = a_0 + a_1 s + a_2 s^2 + a_3 s^3 $$
  - 因为多项式螺旋线是曲率的多项式函数，因此曲率值不会向样条曲线那样剧烈的变化，这使得我们仅使用几个点就可以对曲率进行限制，并且整条曲线都很容易满足曲率约束
  - 这一点在进行路径与优化时是十分重要的，因为在每个优化迭代步中约束条件的增加都会增加计算开销

使用多项式螺旋线的缺点在于其不像五次样条那样有关于位置和航向的闭式解，因此，为了产生满足边界条件的螺旋线，我们依然要使用迭代优化的方式：
$$ x(s) = x_0 + \int_0^s \cos(\theta(s')) ds' \\
   y(s) = y_0 + \int_0^s \sin(\theta(s')) ds' \\
   \theta(s) = \theta_0 + \int_0^s a_3 s'^3 + a_2 s'^2 + a_1 s' + a_0 ds' \\
             = \theta_0 + a_3\frac{s^4}{4} + a_2\frac{s^3}{3} + a_1\frac{s^2}{2} + a_0s $$
  - 可以看出，位置方程是一个Fresnel integrals，其并没有闭式解 
  - 我们使用数值逼近的方法来计算螺旋线的终点，比如基于 Simpson's rule

$$ \int_0^sf(s')ds' \approx \frac{s}{3n}(f(0) + 4f(\frac{s}{n})+ 2f(\frac{2s}{n}) + ... + f(s)) $$

总结：
  - 样条曲线提供了起点和终点位置的闭式解，但螺旋线却无法提供
  - 螺旋曲线确保了曲率沿路径的平滑性，但样条曲线无法提供
  - 总的来讲，样条曲线计算起来较为高效，而螺旋线对曲率约束的实现更为简单
  - 在本教程中，我们使用多项式螺旋线来开发我们的路径规划器，来确保我们局部规划器生成的路径能够被车辆平滑且安全的执行 


## 7.2 优化问题建模
本节我们将讨论如何基于三次螺旋线将之前讨论的问题目标、约束以及边界条件建模成一个优化问题，通过解此优化问题，生成一条平滑的满足上述约束的可行路径。

### 7.2.1 约束条件
对于我们的路径规划优化问题，我们实现要考虑的就是边界条件：
  - 边界条件给出了规划两点间路径的最小要求，给定起始位置、航向和曲率，其要求我们规划出的路径终止于特定的位置、航向和曲率
  - 然而，三次螺旋线并没有螺旋线终点位置的闭式解，为了基于螺旋线参数给出约束项，我们采用数值积分方式

**Simpson's Rule与位置积分**    
Simpson's Rule是一种广泛使用的数值积分技术，它比其他简单的数值方法得到的结果更为精确：
  - 这是因为它评估给定函数二次插值的积分，而不是像其他方法（ midpoint and trapezoidal rules）使用线性插值的积分
  - Simpson rule将积分域等距划分为n个区域，然后在每个区域的边界处评估函数
  <div align=center><img src=./figs/simpson_rule.png width=600></div>

使用Simpson's rule进行位置积分近似的具体形式如下：
<div align=center><img src=./figs/simpson_rule_eg.png width=600></div>

  - 求和公式中的每一项对分界点进行了评估，乘以合适的系数，我们这里轮换使用4，2作为系数，除了在终点处系数为1
  - 因为航向角$\theta$就是对三次螺旋线的积分，因此我们直接得到其四阶多项式的显式解，则我们可以直接利用在分界点出的$\theta$值得到对位置的近似
  - 则根据上式，我们根据任意给定的弧长，则可以求出螺旋线中对与位置$x,y$的近似
  - 当然，随着n的增加，我们可以得到对积分更精确地逼近。但一般$n=8$的精度就足够了，并且次数计算开销也不会太大

**边界条件**  
基于上述逼近公式，我们便可以写出基于螺旋线参数的边界条件的完整形式：
$$ x_s(s_f) = x_f \\
   y_s(s_f) = y_f \\
   \theta_s(s_f) = \theta_f \\
   \kappa(s_f) = \kappa_f $$

**曲率约束**  
通常我们需要对路径施加曲率约束，因为汽车拥有最小的转弯半径并且为了保持轮胎牵引力和乘坐舒适性，还需要受到横向加速度限制
  - a minimum turning radius of two meters. This corresponds to a maximum curvature of 0.5 arc meters
  - 要想对螺旋线的每一点都施加曲率约束是非常困难的，但由于螺旋线的曲率的多项式函数是连续的，我们只需要对少数几个均匀分布的点施加约束，便能得到满足曲率要求的螺旋线
<div align=center><img src=./figs/curvature_constraint.png width=400></div>
  
如图所示，我们分别在曲线的1/3和2/3处施加约束，我们也获得了曲率约束关于螺旋线参数的函数。至此，我们便得到了我们的路径规划优化问题的所有约束条件。

### 7.2.2 目标函数
最后来定义我们想要最小化的目标函数。我们期望我们规划出的轨迹足够平滑和舒适，实现这一目标的方式是将曲率的绝对值均匀的分布在路径上，这可以通过最小化参数曲线的 bending energy 实现。

**Bending Energy Objective**  
Bending energy 是曲率的平方沿着整条路径的积分
$$f_{be}(a_0,a_1,a_2,a_3,s_f) = \int_0^{s_f}(a_0+a_1s+a_2s^2+a_3s^3)^2 ds$$
 - 因为我们有曲率的多项式函数，因此bending energy的积分有关于螺旋线参数的闭式解
 - 其梯度同样拥有闭式解
 - 但因为其闭式解拥有较多的项数，因此最好使用symbolic solver求解

至此我们已经有了目标函数，因此我们可以将约束条件与其写到一起，得到我们优化问题的完整形式：
<div align=center><img src=./figs/optimization_func.png width=600></div>

**Soft Constraints**  
为了进一步简化问题，我们通常假设初始位置的边界条件为0，即我们将局部规划问题定义在车辆坐标系下，这样的话我们就可以将初始位置的边界约束从优化目标中移除。接下来就还剩终点位置和朝向的等式约束，因为等式约束必须精确满足，因此对于数值优化器来讲，从不可行的起始点出发，找到一个可行解是很困难的，解决这一问题的常用方案是将其转化为软的不等式约束
  - 软约束将严格的约束条件转化为目标方程中严重的惩罚项，所以严重惩罚，意味着其惩罚系数至少要比原始优化目标项大一个数量级
  - 尽管这允许优化器违反边界条件等式约束，但强烈鼓励优化器在弯曲能量惩罚项大到足以影响优化器之前收敛到尽可能接近边界条件的解
最终我们的新的优化问题转化为如下形式
<div align=center><img src=./figs/soft_constraints.png width=600></div>

**Parameter Remapping**
最后一个问题是优化参数，虽然使用螺旋线系数作为目标函数参数更为直观，但我们考虑曲率边界约束可以减少参数的数量
  - 我们用一个新的向量$P = [p_0, p_1, p_2, p_3, p_4]$
  - 其中 $p_0$ 到 $p_3$ 分别表示曲线 起始点、1/3处、2/3处和终点处的曲率，$p_4$代表最终的路径弧长
  - 通过将$p_0$ 到 $p_3$带入三阶螺旋线表达式，4个方程4个未知数，则我们可以基于$p_0$ 到 $p_3$求解出$a_0$到$a_3$
  - 因为我们已经知道了初始位置和终点位置的曲率，我们便可以消除两个变量$p_0$ 和 $p_3$,最终只剩下三个优化变量$p_1, p_2, p_4$,可以大大加快计算速度
  - 这样我们就构建新的关于变量$P$的约束和目标方程
  - 求解之后就可以反向计算出螺旋曲线系数

<div align=center><img src=./figs/parameter.png width=600></div>

**Final Optimization Problem**  
最终的优化问题形式如下：
<div align=center><img src=./figs/obj_fun.png width=600></div>


## 7.3 Python 优化器
SciPy优化库包含了一些最流行的优化算法，在实现时保证了其易用性和合理的运行效率。目前很多已经实现的优化算法在参数要求上都比较相似
```python
#nlopt
import scipy.optimize as sp
import numpy as np

bounds = [[-10.0, 5.0], [-3.0, 4.0]] # 约束条件，通常以列表或字典的形式给出
# -10 <= x_0 <= 5, -3 <= x_0 <= 4

x_0 = [1.0, 1.0] # 目标函数的初始值

# 线性约束 Ax<=b; A,b
linear_constraint = LinearConstraint([[1, 2],
[2, 1]], [2, 4])

def objective_function(x):
    return x[0]**2 + 4*x[0]*x[1]
def objective_jacobian(x):
    return np.array([2*x[0] + 4*x[1], 4*x[0]])


result = sp.minimize(objective_function, x_0, method='L-BFGS-B', 
                     jac=objective_jacobian,
                     bounds=bounds, options={'disp' : True})
  # - 通过`method`参数确定要使用的优化算法，目前已经实现了很多主流算法，比如conjugate gradient, Nelder-Mead, dogleg, and BFGS 等
  # - 第一个参数通常使我们想要优化的目标函数，通常以函数指针的形式传递
  # - 不同的`method`参数也决定了优化器是否需要一些额外的参数，比如`L-BFGS-B`算法，不仅需要传递要优化的目标函数，也包含函数的jacobian以及变量的边界，分别通过 `jac`和`bounds`传递
  # - 因为目标模型是单个标量值函数，因此雅克比矩阵退化为梯度

print(result.x)
##Solution:
##>>> [-8. 4.]
```

## 7.4 Conformal Lattice 
Conformal Lattice Planner 和其他路径规划器一样，其目的都是规划一条从无人驾驶车辆当前位置到目标状态的无碰撞路径
  - Conformal Lattice Planner 充分利用道路的结构属性，在避免障碍的同时实现对规划过程的加速：与人类的驾驶行为类似，仅关注相对于目标路径轻微左转或右转的平滑路径，除非遇到紧急情况，一般不会考虑离开当前道路
  - 如图所示，每条规划路径的end point 是沿着center path相对于goal point 横向平移得到的，其中goal point 标记为黄色

路径规划过程中目标状态的选择存在典型的trad off
  - 如果我们选择的目标点与车辆当前位置较为接近，可以大大减少计算时间，但是，也降低了规划器以平稳舒适的方式避开路径上更远的障碍物的能力，当车速较快时可能会出现问题。
  - 通常来讲，goal horizon在规划时时动态计算的，取决与车速、天气条件等因素
  - 在本教程中，我们将采用固定的goal horizon，我们将使用车道中心线的一定距离的点作为goal point,如右图所示，其中蓝色的点目标点的替代点
<div align=center><img src=./figs/conformal_lattice.png width=600></div>

###  7.4.1 路径生成
一旦确定了目标状态，我们就可以利用上节中构建的目标函数

$$ min \quad f_{be}(a_0, a_1, a_2, a_3, s_f) + \alpha(x_S(p_4)-x_f) + \beta(y_S(p_4)-y_f) + \gamma(\theta_S(p_4)-\theta_f) \\
   s.t. \quad |p_1| \leq \kappa_{max} \\
   s.t. \quad |p_2| \leq \kappa_{max} $$

求解出从当前位置出发到每个目标位置对应的三次螺旋线。我们这里先仅考虑运动学约束，暂时不考虑每天路径是否是无碰撞的
  - 如果某条螺旋线在运动学上是不可行的或无法到达目标路径,则我们直接丢弃此螺旋线并不再将其看做潜在路径
  - 注意我们的优化问题求解得到的是参数变量$P$，因此还需要逆变换得到原始的螺旋线参数
  - 一旦我们得到了曲线参数，我们就可以沿着螺旋线进行采样得到一系列点，得到整条路径的离散表示

因为我们并没有沿着螺旋线位置的闭式解，所以需要进行数值积分得到
$$ x(s) = x_0 + \int_0^s \cos(\theta(s')) ds' \\
   y(s) = y_0 + \int_0^s \sin(\theta(s')) ds' \\ $$

这次我们基于线性插值，利用trapezoid rule来进行实现，trapezoid rule 相比于 Simpson's rule 计算起来更为高效
  - 因为沿着曲线的每一个后续点都可以利用之前的点进行生成，因此我们沿着曲线进行一次扫描就可以得到所有的点
  - 而 Simpson's rule 对于每一个点都要求进行积分近似
  - 在python中，我们可以在使用 `comulative_trapezoid()`螺旋线关于位置的位置的离散表示

$$ \int_0^s f(x)dx \approx \sum_{i=1}^{N-1} \frac{f(x_{i+1}+f(x))}{2}(x_{i+1}-x_i) $$

<div align=center><img src=./figs/trapezoidal_rule.png width=400></div>

注意：
  - 除了每个点的位置，其朝向和曲率对于我们后续速度规划也是十分中重要的
  - 但因为我们有关于航向和曲率的闭式解，因此不需要使用数值积分

### 7.4.2 碰撞检查
进而我们得到了一个完整的路径集合，接下来我们需要对每条路径进行碰撞检查
  - 我们可以使用条带法利用占据格栅地图实现
    - 我们可以基于占据栅格，将车辆足迹沿着螺旋线的每一点进行移动，最后生成路径的条带
    - 如果该条带在占据网格中的某个网格包含障碍物，则此代表此路径将会与其他障碍物发生碰撞
    - 如果该条带占据的每一个网格都不包含障碍物，则为无碰撞路径
  - 当然也可以使用圆来进行碰撞检查：
    - 沿着每个路径点放置车辆的逼近圆，检查每个障碍物是否位于此圆内
  - 最中进行碰撞检查后的结果如图所示，红色为碰撞路径，绿色为无碰撞路径

<div align=center><img src=./figs/collision_checking.png width=600></div>

### 7.4.3 路径选择
至此，我们获得了一个可行的无碰撞的路径集合，最后我们需要进行路径选择，选择出一条最优的跟踪路径。
  - 选择的过程需要进行具体的设计，可能有多种原则用作考虑因素
  - 比如我们可以选择尽可能原理障碍物的路径，因此我们可以对距离障碍物较近的路径进行惩罚
  - 或者我们也想惩罚偏移最近中心线较远的路线
  - 这里我们简单的选择距离中心目标点尽可能近的路径，具体的惩罚项形式无所谓，只要偏离中心目标点越远，惩罚越大即可：即我们的规划器期望选择沿着参考路径的路径，只有当参考路径不可行或与其他障碍物发生碰撞时，才允许稍微偏移参考路径
  - 我们迭代评估所有可行路径，然后选择最优路径，如图蓝色路径

<div align=center><img src=./figs/path_selection.png width=600></div>

随着车辆沿着路径前进，我们不断重复上述过程，则我们的规划器可以不断的规划出在避免碰撞的同时朝着目标点前进的路径。与之前呈现的反应式规划器类似，conformal lattice planner也是以一种滚动优化的方式向着目标点前进。


## 7.5 速度生成
本节我们将介绍为指定的规划路径生成对应速度的方法。影响速度生成包含许多不同的因素
  - 比如行为规划器提供的参考速度
  - 车辆前方动态目标的速度
  - 以及为了保证乘客舒适性和车辆稳定性所需要的速度等

### 7.5.1 终点速度
生成速度的第一步就是确定最终要求的速度

**行为规划器参考速度**  
对于最终速度一个很好的初始值是行为规划器给出的参考速度，而参考速度又很大程度上受到行为规划器基于当前驾驶场景做出的决策行为的影响
  - 比如，如果行为规划器因为红灯决定执行在路口处停车，则行为规划器会输出一个停车决策附带一个速度为0的参考速度
  - 如果我们当前沿着直线行驶，参考速度可能直接就是当前道路的限速

我们将行为规划器给出的参考速度用$V_{ref}$表示。

**碰撞时间**  
接下来我们考虑动态障碍物的状态，特别是前车的状态
  - 本车速度将依据前车速度进行调整，因为如果本车速度超过了前车速度，则将最终导致碰撞
  - 碰撞时间(TTC)是关于本车与前车相对速度与路径长度$s$的函数
  - 因此，为了维持一个防止碰撞的安全时间，本车的参考速度将采用前车速度与行为规划参考速度的最小值

除此之外，我们还需要确保在到达前车当前位置之前主车速度仍然要小于前车速度，否则仍然有发生碰撞的风险。常见的做法是在处理动态障碍时，我们保留一个距离和时间的缓冲：
  - 假设我们的规划路径的终点在前车的位置之前，我们需要确保在前车位置之前实现我们的最终速度，这样可以留出一个空间上的缓冲，如图中红点所示
  - 比如我们的最终速度为前车速度，这样我们在红点处与前车速度保持一致，这样即使最初前车速度比本车速度慢，当到达红点时，辆车速度相同，前车继续前进，本车与其保持一个防止碰撞的安全距离也跟车前进

<div align=center><img src=./figs/safe_distance.png width=400></div>

当然我们也可以通过给定前车速度，通过车辆跟踪来确保一个安全时间或安全距离，但这样使控制函数从相对速度的跟踪变成了相对距离的跟踪，因此在本教程中我们仍然使用基于速度的方法。

**横向加速度限制**  
最后要考虑的因素是沿着规划路径的最大曲率限制。在上一小节我们进行最优路径采样时，我们同时也会记录螺旋曲线中每个点的对应曲率，用$\kappa_i$表示。除此之外，我们在第一章中也提到了车辆应运行在comfort rectangle,因此对车辆还有最大横向加速度$a_{lat}$限制，横向加速度是关于瞬时曲率和沿着曲线纵向速度的函数。
  $$ v_k \leq \sqrt{\frac{a_{lat}}{\kappa_i}} $$

因此，曲率限制了我们沿着路径行驶的纵向速度。我们可以通过在路径上的每一点确保车辆速度低于限速来保证曲率约束，但如果曲率变化较快，同时由于纵向加速度的限制，我们可能无法达到期望的速度。
  - 我们可以通过寻找路径中所有点的最大曲率来确定相关的最大速度
  - 然后我们生成的速度必须确保在路径最大曲率点之前达到此最大速度，因此我们可以在速度最小点定义减速至期望速度，反之在最大点定义加速至最大速度
  - 我们不断重复此过程直到生成的速度满足整条路径上的曲率约束

<div align=center><img src=./figs/curvature.png width=400></div>

还有一个更为简单的方法是直接确定最大曲率点，然后设定相关速度，然后简单的保持此速度直到通过此最大曲率点。
  - 因为我们是以滚动优化的方式不断进行连续的重规划的，因此当我们到达最大曲率点时，新的速度将会基于之前定义的其他目标方程再次产生

最后，我们可以将整个速度生成过程简化为同时结合 基于曲率约束的最大速度、行为规划器以及前车速度的最大速度，结合方式为

$$ v_f = min (v_{ref}, v_{lead}, v_k) $$


### 7.5.2 线性斜坡速度
接下来我们讨论对于velocity profile我们期望的形状。一种简单的选择可以从当前速度到终点速度直接生成一个线性斜坡。在进行速度规划时，我们目前已知的量有 路径的总弧长$s$，初始速度$v_0$以及最终速度$v_f$：
  - 首先需要从给定输入直接计算期望的加速度
  $$ a = \frac{v_f^2-v_0^2}{2s} $$
  - 另外，我们需要确保计算出的加速度不能超出我们的舒适度矩形，如果确实超出，则需要clamp 它。通过使用最大加速度来重新计算末速度
  $$ v_f = \sqrt{2a_{max}s + v_0^2} $$

<div align=center><img src=./figs/linear_ramp.png width=400></div>

一旦我们有了加速度曲线，我们就可以通过查看到第 i 个点的弧长来计算路径上每个点的速度。 通过遍历整个路径并计算每个点所需的速度，我们已经完全生成了沿路径的速度剖面，以达到我们想要的最终速度。
  $$ v_fi = \sqrt{2a}s_i + v_0^2} $$


### 7.5.3 梯形速度
另一种是梯形速度，常用于汽车接近停车标志的速度规划，我们希望车辆首先从常规速度减速到较低的行驶速度，然后再次减速直至在停车标志处停车。对于此速度规划，我们将初速度、末速度、期望的转移速度以及期望的负加速度作为输入(负加速度通常选择位于舒适度矩形内部，以使规划出的速度尽可能平滑)：
  - 该速度规划器的第一步是计算从初始速度出发减速至期望转移速度所需要的距离
    $$ s_a = \frac{v_t^2 - v_0^2}{2a_0} $$
  - 一旦我们得到此弧长$s_a$, 则可迭代计算该弧长上每个点对应的速度
    $$ v_i = \sqrt{2a_0s_i + v_0^2} $$
  - 最后一段则可采用和上述类似的步骤，计算从转移速度到减速至停车整段弧长上的每个点对应的位置
    $$ s_f - s_b = \frac{0-v_t^2}{2a_0} $$
  - 有上式得到$s_b$，我们可以迭代该段弧长上的每一个路径点，然后分配定常的转移速度$v_t$

最终整个速度规划过程如下：
<div align=center><img src=./figs/trapezoidal_profile.png width=600></div>

当然，除了上述两种速度生成方法，还有很多其他方法：
  - 使用biquadratic velocity planners等更高阶的速度规划方法，可以最小化沿着轨迹的jerk
  - 当然也可以在上述两种速度斜坡中使用更高阶的函数，使得生成的速度更为平滑和舒适
  - 最终，可以优化速度曲线以同时满足多个目标，同时满足取决于要执行的行为的舒适性和安全性约束。


## 7.6 补充阅读材料
  - [1]. A. Kelly and B. Nagy, “[Reactive Nonholonomic Trajectory Generation via Parametric Optimal Control](https://journals.sagepub.com/doi/abs/10.1177/02783649030227008?casa_token=1eJaU-j-rQMAAAAA%3AkOxyZCACePcPX12nrkI9ytr-xQC0KY9nZ_TZ4m7ClMuSbHmpA8TOnlmNMDQVxa7-K_9bEtOFm820&),” The International Journal of Robotics Research, vol. 22, no. 7, pp. 583–601, 2003. This paper discusses the math behind generating spirals to desired terminal states.
  - [2]. A. Piazzi and C. G. L. Bianco, “[Quintic G/sup 2/-splines for trajectory planning of autonomous vehicles](https://ieeexplore.ieee.org/abstract/document/898341),” Proceedings of the IEEE Intelligent Vehicles Symposium 2000 (Cat. No.00TH8511).  This paper discusses the math behind generating quintic splines to desired terminal states.
  - [3]. M. Mcnaughton, C. Urmson, J. M. Dolan, and J.-W. Lee, “[Motion planning for autonomous driving with a conformal spatiotemporal lattice](https://ieeexplore.ieee.org/abstract/document/5980223),” 2011 IEEE International Conference on Robotics and Automation, 2011.  This paper introduces the concepts behind generating a conformal spatiotemporal lattice for on-road motion planning.